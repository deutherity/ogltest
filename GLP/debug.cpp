#include <GL/glew.h>
#include <iostream>
#include "debug.hpp"
#include <mutex>

#ifdef _WIN32
#include <windows.h>
#else
#define APIENTRY
#endif


inline static GLP::debugErrorLevel getErrorLevel(GLenum severity)
{
    using namespace GLP;
    switch (severity)
    {
    case GL_DEBUG_SEVERITY_HIGH:
        return DEBUG_HIGH;
    
    case GL_DEBUG_SEVERITY_MEDIUM:
        return DEBUG_MEDIUM;
    
    case GL_DEBUG_SEVERITY_LOW:
        return DEBUG_LOW;
    
    case GL_DEBUG_SEVERITY_NOTIFICATION:
        return DEBUG_NOTE;
    
    default:
        return DEBUG_ALL;
    }
}


static GLP::debugErrorLevel errorLevelNeeded {GLP::DEBUG_NONE} ;
static std::mutex debugIOmutex;

static void APIENTRY debugCallback(
            GLenum source, GLenum type,
            GLuint id, GLenum severity,
            GLsizei length,
            const GLchar *message,
            const void *nothing)
{
    if (static_cast<unsigned char>(getErrorLevel(severity)) > static_cast<unsigned char>(errorLevelNeeded)) {
        std::cout << "Message lvl " << static_cast<unsigned int>(getErrorLevel(severity)) << " omitted. Needed lvl " << static_cast<unsigned int>(errorLevelNeeded) << '\n';
        return;
    }

    static constexpr auto* stick = "====================";
    

    // std::lock_guard lockForIO(debugIOmutex);
    std::cout << stick << '\n';
    std::cout << "OGL DEBUG MESSAGE!\n"
    "Id:\t\t" << id << '\n';


    std::cout << "Generated by:\t"
              << ([&]() -> const char* {
        switch (source)
        {
        case GL_DEBUG_SOURCE_API:
            return "Calls to the OpenGL API";
            break;

        case GL_DEBUG_SOURCE_WINDOW_SYSTEM:
            return "Calls to a window-system API";
            break;

        case GL_DEBUG_SOURCE_SHADER_COMPILER:
            return "A compiler for a shading language";
            break;

        case GL_DEBUG_SOURCE_THIRD_PARTY:
            return "An application associated with OpenGL";
            break;
            
        case GL_DEBUG_SOURCE_APPLICATION:
            return "The user of this application";
            break;       
        
        case GL_DEBUG_SOURCE_OTHER:
            return "Undefined";
            break;
        
        default:
            return "Undefined";
            break;
        }
    })()
              << '\n';
    
    std::cout << "Message type:\t" 
              << ([&]() -> const char* {
                switch (type)
                {
                case GL_DEBUG_TYPE_ERROR:
                    return "An error, typically from the API";
                    break;
                case GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR:
                    return "Some behavior marked deprecated has been used";
                    break;
                case GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR:
                    return "Something has invoked undefined behavior";
                    break;
                case GL_DEBUG_TYPE_PORTABILITY:
                    return "Some functionality the user relies upon is not portable";
                    break;
                case GL_DEBUG_TYPE_PERFORMANCE:
                    return "Code has triggered possible performance issues";
                    break;
                case GL_DEBUG_TYPE_MARKER:
                    return "Command stream annotation";
                    break;
                case GL_DEBUG_TYPE_PUSH_GROUP:
                    return "Group pushing";
                    break;     
                case GL_DEBUG_TYPE_POP_GROUP:
                    return "Pop debug";
                    break; 
                default:
                    return "Undefined";
                    break;
                }
            })()
              << '\n';

    std::cout << "Severity:\t"
              << ([&]() -> const char* {
                switch (severity)
                {
                case GL_DEBUG_SEVERITY_HIGH:
                    return "All OpenGL Errors, shader compilation/linking errors, or highly-dangerous undefined behavior";
                    break;

                case GL_DEBUG_SEVERITY_MEDIUM:
                    return "Major performance warnings, shader compilation/linking warnings, or the use of deprecated functionality";
                    break;
                 
                case GL_DEBUG_SEVERITY_LOW:
                    return "Redundant state change performance warning, or unimportant undefined behavior";
                    break;

                case GL_DEBUG_SEVERITY_NOTIFICATION:
                    return "Anything that isn't an error or performance issue.";
                    break;

                default:
                    return "Undefined";
                    break;
                }
              })()
              << '\n';

    std::cout << "Message:\t";
    std::cout.write(message, length);
    std::cout << '\n' << stick << '\n';

}

namespace GLP
{
    void setDebugErrorlevel(debugErrorLevel errorLevel)
    {
        if (errorLevelNeeded == errorLevel)
        {
            return;
        }
        
        auto prev = errorLevelNeeded;
        errorLevelNeeded = errorLevel;
        std::cout << "GLP debug level set: "
                  <<  ([&]() -> const char *{
            switch (errorLevel)
            {
            case DEBUG_NONE:
                return "No messages";
                break;

            case DEBUG_HIGH:
                return "High";
                break;
            
            case DEBUG_MEDIUM:
                return "Medium";
                break;
            
            case DEBUG_LOW:
                return "Low";
                break;
            
            case DEBUG_NOTE:
                return "Notifications";
                break;
            
            case DEBUG_ALL:
                return "All messages";
                break;
            
            default:
                return "Undefined";
                break;
            }
        })() 
                  << '\n';

        if (errorLevel == DEBUG_NONE)
        {
            glDisable(GL_DEBUG_OUTPUT);
        }
        else if (prev == DEBUG_NONE)
        {
            glEnable(GL_DEBUG_OUTPUT);
            glDebugMessageCallback(debugCallback, nullptr);
        }
    }

    debugErrorLevel getDebugErrorLevel()
    {
        return errorLevelNeeded;
    }

} // namespace GLP

